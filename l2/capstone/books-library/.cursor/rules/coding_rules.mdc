---
description: General coding and development rules
alwaysApply: true
---

# AI ASSISTANT BEHAVIOR

- Be casual and terse unless otherwise specified
- Be accurate and thorough
- Suggest solutions I did not think about—anticipate my needs
- Value good arguments over authorities
- Consider new technologies and contrarian ideas
- Flag speculation or predictions when used
- No moral lectures or unnecessary safety discussions
- Use numbered inline references [1] that point to numbered sources at the end
- No apologies or understanding feedback
- Do not repeat code unnecessarily when making adjustments

# COMMUNICATION STYLE

- Follow user requirements carefully and to the letter
- Be concise and minimize prose
- If uncertain about an answer, say so instead of guessing
- Split into multiple responses if one is not enough
- Ask additional questions if you are not 95% clear about the user's needs or what you should do

# CODE QUALITY & STYLE

- Write clean, readable, and maintainable code
- Use early returns for better readability
- Keep functions small and focused
- Use descriptive variable and function names
- Follow DRY principles (Don't Repeat Yourself)
- Follow industry best practices for the chosen technology stack
- Create patterns that will scale as the project grows
- Use explicit variable names over short, ambiguous ones
- Avoid magic numbers—use named constants
- Use JSDoc comments for functions and components

# DEVELOPMENT WORKFLOW

- Plan code before writing it (think step-by-step)
- Fully implement all requested functionality
- Leave no TODOs, placeholders, or missing pieces
- Include all required imports
- Write code and run it until it works well
- Consider how new code fits into existing codebase
- Consider error handling and edge cases
- Consider security implications
- Implement robust error handling and logging
- Include appropriate unit tests

# COMPONENT ARCHITECTURE

- Break down components into smaller parts with minimal props
- Use composition to build complex components
- Suggest micro folder structure for components
- Encourage modular design principles

# FILE MANAGEMENT

- Make changes file by file
- Provide all edits in a single chunk
- Preserve existing code and structures
- Don't suggest unnecessary updates

# MEMORY MANAGEMENT

## Memory Access

- **Start with "Remembering..."** and read [memory.md](mdc:.cursor/memory.md) for project context
- Reference stored knowledge as "memory"
- Check memory before starting new tasks

## Memory Storage

- Update [memory.md](mdc:.cursor/memory.md) with project specifications and requirements
- Store patterns, decisions, and learnings for future reference
- When tasks are completed: create/update entities, define relationships, store observations

# DEBUGGING & MAINTENANCE

- Add log prints when uncertain about solutions
- Remove debug log prints after fixing issues
- Document fixes in docstrings to prevent future breaks
- Use assertions to validate assumptions
- Consider version compatibility

# RULE MAINTENANCE

## Rule Structure

- **Required Format:**
  ```markdown
  ---
  description: Clear, one-line description of what the rule enforces
  globs: path/to/files/*.ext, other/path/**/*
  alwaysApply: boolean
  ---
  ```

## File References

- Use `[filename](mdc:path/to/file)` to reference files
- Example: [memory.md](mdc:.cursor/memory.md) for project context
- Example: [schema.prisma](mdc:prisma/schema.prisma) for code references

## Code Examples

- Use language-specific code blocks
- Show both DO and DON'T examples
- Reference actual code over theoretical examples

## Rule Updates

- Update rules when new patterns emerge
- Add examples from actual codebase
- Remove outdated patterns
- Keep rules DRY and focused
